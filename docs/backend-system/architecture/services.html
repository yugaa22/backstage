<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Backend Services · Backstage Software Catalog and Developer Platform</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Services for backend plugins"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Backend Services · Backstage Software Catalog and Developer Platform"/><meta property="og:type" content="website"/><meta property="og:url" content="https://backstage.io/"/><meta property="og:description" content="Services for backend plugins"/><meta property="og:image" content="https://backstage.io/img/sharing-opengraph.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://backstage.io/img/twitter-summary.png"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/monokai.min.css"/><link rel="alternate" type="application/atom+xml" href="https://backstage.io/blog/atom.xml" title="Backstage Software Catalog and Developer Platform Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://backstage.io/blog/feed.xml" title="Backstage Software Catalog and Developer Platform Blog RSS Feed"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-KSEVGGNCJW"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments); }
              gtag('js', new Date());
              gtag('config', 'G-KSEVGGNCJW');
            </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono:500,700&amp;display=swap"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://unpkg.com/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script><script type="text/javascript" src="/js/medium-zoom.js"></script><script type="text/javascript" src="/js/dismissable-banner.js"></script><script type="text/javascript" src="/js/scroll-nav-to-view-in-docs.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><h2 class="headerTitle">Backstage Software Catalog and Developer Platform</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="https://github.com/backstage/backstage" target="_self">GitHub</a></li><li class=""><a href="/docs/overview/what-is-backstage" target="_self">Docs</a></li><li class=""><a href="/plugins" target="_self">Plugins</a></li><li class=""><a href="/blog" target="_self">Blog</a></li><li class=""><a href="/docs/releases/v1.10.0" target="_self">Releases</a></li><li class=""><a href="/demos" target="_self">Demos</a></li><li class=""><a href="/community" target="_self">Community</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/backstage/backstage/edit/master/docs/backend-system/architecture/03-services.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Backend Services</h1></header><article><div><span><p>Backend services provide shared functionality available to all backend plugins and modules. They are made available through service references that embed a type that represents the service interface, similar to how <a href="/docs/api/utility-apis">Utility APIs</a> work in the Backstage frontend system. To use a service in your plugin or module you request an implementation of that service using the service reference.</p>
<p>The system surrounding services exists to provide a level of indirection between the service interfaces and their implementation. It is an implementation of dependency injection, where each backend instance is the dependency injection container. The implementation for each service is provided by a service factory, which encapsulates the logic for how each service instance is created.</p>
<h2><a class="anchor" aria-hidden="true" id="service-interfaces"></a><a href="#service-interfaces" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Service Interfaces</h2>
<p>Service interfaces can be any TypeScript type, but it is best to make it an object interface with a number of methods. General guidelines for interface design apply: keep them simple and lean, with few but powerful methods. Take care to avoid locking down the ways in which individual methods can evolve. Often you want to stick to a method with an options object as its only parameter, and return a result object. If there is any reason for uncertainty about whether the method should be async or not, always make it async. For example, a minimal interface should often use the following pattern:</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> FooService {
  foo(options: FooOptions): <span class="hljs-built_in">Promise</span>&lt;FooResult&gt;;
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="service-references"></a><a href="#service-references" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Service References</h2>
<p>Once you have defined a service interface, you need to create a service reference using the <code>createServiceRef</code> function. This will create a <code>ServiceRef</code> instance, which is a reference that you export in order to allow users to interact with your service. Conceptually this is very similar to <code>ApiRef</code>s in the frontend system. For example:</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">import</span> { createServiceRef } <span class="hljs-keyword">from</span> <span class="hljs-string">'@backstage/backend-plugin-api'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> FooService {
  foo(options: FooOptions): <span class="hljs-built_in">Promise</span>&lt;FooResult&gt;;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> fooServiceRef = createServiceRef&lt;FooService&gt;({
  id: <span class="hljs-string">'example.foo'</span>, <span class="hljs-comment">// the owner of this service is in this case the 'example' plugin</span>
});
</code></pre>
<p>The <code>fooServiceRef</code> that we create above should be exported, and can then be used to declare a dependency on the <code>FooService</code> interface and receive an implementation of it at runtime.</p>
<p>When creating a service reference you need to give it an ID. This ID needs to be globally unique, and should generally be of the format <code>'&lt;pluginId&gt;.&lt;serviceName&gt;'</code>. For more naming patters surrounding services, see the <a href="/docs/backend-system/architecture/naming-patterns#services">naming patterns</a> page.</p>
<p>A note on naming: the frontend and backend systems intentionally use the separate names &quot;APIs&quot; and &quot;Services&quot; for concepts that are quite similar. This is to avoid confusion between the two, both in documentation and discussion, but also in code. While the two systems are quite similar, they are not identical, and they can't be used interchangeably.</p>
<h2><a class="anchor" aria-hidden="true" id="service-factories"></a><a href="#service-factories" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Service Factories</h2>
<p>In order to be able to depend on a service interface through a service reference, we of course also need to have some way of creating the concrete implementation of it. To encapsulate that logic we use service factories, which define both how service instances are created, as well as what other services they depend on for their implementation.</p>
<p>Service factories can come from many different sources. There are built-in service factories, external ones that you can import from other packages, and you can also create your own. Specific service factories are installed within each backend instance, which acts as the dependency injection container. For any given backend instance there can only be a single designated service factory for each service.</p>
<p>To define a service factory, we use <code>createServiceFactory</code>:</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">import</span> { createServiceFactory } <span class="hljs-keyword">from</span> <span class="hljs-string">'@backstage/backend-plugin-api'</span>;

<span class="hljs-keyword">class</span> DefaultFooService <span class="hljs-keyword">implements</span> FooService {
  <span class="hljs-keyword">async</span> foo(options: FooOptions): <span class="hljs-built_in">Promise</span>&lt;FooResult&gt; {
    <span class="hljs-comment">// ...</span>
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> fooFactory = createServiceFactory({
  service: fooServiceRef,
  deps: { bar: barServiceRef },
  factory({ bar }) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultFooService(bar);
  },
});
</code></pre>
<p>To create a service factory we need to provide a reference to the <code>service</code> for which the factory will create instances, a <code>deps</code> object which lists the other services that the factory depends on, and a <code>factory</code> function which will be called to create the service instance. The backend system will call the <code>factory</code> function with an object that contains the service instances for each of the dependencies listed in the <code>deps</code> object. If a service implementation does not depend on any other services, the <code>deps</code> are left as an empty object (<code>{}</code>). The <code>factory</code> function must return a value that implements the service interface.</p>
<p>If you need the creation of the service instance to be asynchronous, you can make the <code>factory</code> function async. For example:</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> fooFactory = createServiceFactory({
  service: fooServiceRef,
  deps: {},
  <span class="hljs-keyword">async</span> factory() {
    <span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> DefaultFooService();
    <span class="hljs-keyword">await</span> foo.init();
    <span class="hljs-keyword">return</span> foo;
  },
});
</code></pre>
<p>Note that circular dependencies among service factories are not allowed. This is verified at runtime, and your backend instance will refuse to start up if it detects any conflicts. Likewise, the backend will also fail to start up if a service factory depends on a service that is not provided by any registered service factory.</p>
<h2><a class="anchor" aria-hidden="true" id="service-factory-options"></a><a href="#service-factory-options" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Service Factory Options</h2>
<p>To install a service factory in a backend instance, we pass it in through the <code>services</code> option to <code>createBackend</code>:</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">const</span> backend = createBackend({
  services: [fooFactory()],
});
</code></pre>
<p>Note that we call <code>fooFactory</code> to create the service factory instance. This is because <code>createServiceFactory</code> always returns a factory function that creates the actual service factory. This is done to always allow for options to be added to the service factory in the future, without breaking existing code. To add options to your service factory, you wrap the object passed to <code>createServiceFactory</code> in a callback that accepts the desired options. For example:</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> FooFactoryOptions {
  mode: <span class="hljs-string">'eager'</span> | <span class="hljs-string">'lazy'</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> fooFactory = createServiceFactory(
  <span class="hljs-function">(<span class="hljs-params">options?: FooFactoryOptions</span>) =&gt;</span> ({
    service: fooServiceRef,
    deps: { bar: barServiceRef },
    factory({ bar }) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultFooService(bar, options?.mode);
    },
  }),
);
</code></pre>
<p>This lets us use the options to customize the factory implementation in any way we want. From the outside the service factory looks just like before, except that we're now also able to pass options when installing the factory:</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">const</span> backend = createBackend({
  services: [fooFactory({ mode: <span class="hljs-string">'eager'</span> })],
});
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="core-services"></a><a href="#core-services" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Core Services</h2>
<p>The backend system provides a number of core service definitions that both help implement the main functionality of the backend, but also provide a set of utilities for common concerns, such as logging, database access, job scheduling, and so on. These core services will always be present in a backend instance created with <code>createBackend</code>, and they can all be overridden with custom implementations if needed.</p>
<p>The service references for all core services are exported via their own <code>coreServices</code> object, available from the <code>@backstage/backend-plugin-api</code> package. For example, the logging service is accessible via <code>coreServices.logger</code>.</p>
<p>You can read more about what core services there are and how to use them in the <a href="/docs/backend-system/core-services/">core services</a> section.</p>
<h2><a class="anchor" aria-hidden="true" id="service-scope"></a><a href="#service-scope" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Service Scope</h2>
<p>By default services are scoped to individual plugins, meaning that separate instances of the service will be created for each plugin. For example, in our <code>fooFactory</code> above, a separate instance of <code>DefaultFooService</code> will be created for every plugin that depends on the service. This both makes it possible to tailor the service implementations for the individual plugins, and also ensures some level of separation between plugins.</p>
<p>The service scope is defined during the call to <code>createServiceRef</code>, with plugin scope being the default. Our above definition of the <code>fooServiceRef</code> is therefore equivalent to the following:</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> fooServiceRef = createServiceRef&lt;FooService&gt;({
  scope: <span class="hljs-string">'plugin'</span>,
  id: <span class="hljs-string">'example.foo'</span>,
});
</code></pre>
<p>There are only two possible scopes for services, <code>'plugin'</code> and <code>'root'</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="root-scoped-services"></a><a href="#root-scoped-services" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Root Scoped Services</h2>
<p>If a service is defined as a root scoped service, the implementation created by the factory will be shared across all plugins and services. One other differentiating factory for root scoped services is that they are always initialized, regardless of whether any plugins depend on them or not. This makes them suitable for implementing backend-wide concerns that are not specific to any individual plugin.</p>
<p>There is a limitation in the usage of root scoped services, which is that their implementation can only depend on other root scoped services. Plugin scoped services on the other hand can depend on both root and plugin scoped services. Because of this limitation, one of the main reasons to define a root scoped services is to make it possible for other root scoped services to depend on it.</p>
<p>Because of these limitations and particular use-cases for root scoped services, they tend to be more rare than plugin scoped services. In general, you should prefer defining a service as plugin scoped, unless you are implementing either of the two mentioned use-cases.</p>
<p>Some services come in pairs of a plugin and a root scoped service definition. For example, the <code>rootLogger</code> service is a root scoped service, while the <code>logger</code> service is a plugin scoped service. The <code>rootLogger</code> service houses the main logging implementation, while the <code>logger</code> service simply builds upon the <code>rootLogger</code> to add plugin specific labels. This division exists so that other root scoped services also have access to a logging service, but it is always preferable if the split can be avoided. If you do end up implementing this pattern, the root scoped service should be prefixed with <code>root</code>, this is to encourage use of the plugin scoped service instead.</p>
<h2><a class="anchor" aria-hidden="true" id="plugin-metadata"></a><a href="#plugin-metadata" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Plugin Metadata</h2>
<p>Plugin scoped services have access to a plugin metadata service, which is a special service provided by the backend system that is not possible to override. The plugin metadata service provides information about the plugin that a service instance is being created for. It is itself a plugin scoped service, and can be depended on like any other service through the <code>coreServices.pluginMetadata</code> reference.</p>
<p>The plugin metadata service is the base for all plugin specific customizations for services. For example, the default implementation of the plugin scoped logger service uses the plugin metadata service to attach the plugin ID as a field in all log messages:</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> loggerFactory = createServiceFactory({
  service: coreServices.logger,
  deps: {
    rootLogger: coreServices.rootLogger,
    pluginMetadata: coreServices.pluginMetadata,
  },
  factory({ rootLogger, pluginMetadata }) {
    <span class="hljs-keyword">return</span> rootLogger.child({ plugin: pluginMetadata.getId() });
  },
});
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="root-context-for-service-factories"></a><a href="#root-context-for-service-factories" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Root Context for Service Factories</h2>
<p>Some services may benefit from having a context that is shared across all instances of a service. This of course only applies to plugin scoped services, as root scoped services only ever have a single instance. The root context could for example be used for sharing a common connection pool for database access, generated secrets for development, or any other kind of shared facility. Note that you should not use this to share state between plugins in production, as that would be a violation of the <a href="/docs/backend-system/architecture/plugins#rules-of-plugins">plugin isolation rule</a>.</p>
<p>The root context is defined as part of the service factory by passing the <code>createRootContext</code> option:</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> fooFactory = createServiceFactory({
  service: fooServiceRef,
  deps: { rootLogger: coreServices.rootLogger, bar: barServiceRef },
  createRootContext({ rootLogger }) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FooRootContext(rootLogger);
  }
  factory({ bar }, ctx) {
    <span class="hljs-keyword">return</span> ctx.forPlugin(bar)
  },
});
</code></pre>
<p>Whatever value is returned by the <code>createRootContext</code> function will shared and passed as the second argument to each invocation of the <code>factory</code> function. That way you can create a shared context that is used in the creation of each plugin instance. Unlike the <code>factory</code> function, the <code>createRootContext</code> function will only receive root scoped services as its dependencies, but just like the <code>factory</code> function, it can also be <code>async</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="default-service-factories"></a><a href="#default-service-factories" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Default Service Factories</h2>
<p>There are a lot of services that are installed in any standard Backstage backend instance by default. You can expect these services to always exist, and do not need to take any additional steps to make them available. This is not necessarily true for services that you import from external packages, as the user of your plugin or module might not have installed a factory for that service in their backend. In order to avoid having to ask integrators of your plugin to install a service factory for a service that you depend on, it is possible to define a default factory for a service.</p>
<p>Default service factories are defined as part of the service reference by passing the <code>defaultFactory</code> option to <code>createServiceRef</code>:</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">import</span> {
  createServiceFactory,
  createServiceRef,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@backstage/backend-plugin-api'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> fooServiceRef = createServiceRef&lt;FooService&gt;({
  id: <span class="hljs-string">'example.foo'</span>,
  defaultFactory: <span class="hljs-keyword">async</span> service =&gt;
    createServiceFactory({
      service,
      deps: {},
      factory() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultFooService();
      },
    }),
});
</code></pre>
<p>Note that we don't use the <code>fooServiceRef</code> when creating our service factory, but instead use the <code>service</code> parameter in the default factory callback. This is because attempting to use <code>fooServiceRef</code> directly would result in a circular reference.</p>
<p>If a service defines a default factory, that factory will be used if there is no explicit factory registered in the backend for that service. This allows users of your service to directly import and use a service, without worrying about whether it is installed or not. It is recommended to always define a default factory for any service that you are exporting for use in other plugins or modules.</p>
<p>When defining a default factory for a service, it is possible for it to end up with duplicate implementations at runtime. This applies both to any shared root context in your factory, as well as plugin specific instances of your service. This is because package dependency version ranges may not line up perfectly, causing duplicate installations of the same package. This can happen both for two different plugins using the same service, but also across a plugin and its modules. If your service would break in this scenario, you should not define a default factory for it, but instead require that users of your service explicitly install a factory in their backend instance.</p>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 2/1/2023</em></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#service-interfaces">Service Interfaces</a></li><li><a href="#service-references">Service References</a></li><li><a href="#service-factories">Service Factories</a></li><li><a href="#service-factory-options">Service Factory Options</a></li><li><a href="#core-services">Core Services</a></li><li><a href="#service-scope">Service Scope</a></li><li><a href="#root-scoped-services">Root Scoped Services</a></li><li><a href="#plugin-metadata">Plugin Metadata</a></li><li><a href="#root-context-for-service-factories">Root Context for Service Factories</a></li><li><a href="#default-service-factories">Default Service Factories</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><div class="footer-title"><a href="/"><h2 class="footerLogo"></h2></a></div><div><h5>Docs</h5><a href="/docs/overview/what-is-backstage">What is Backstage?</a><a href="/docs/getting-started/">Getting started</a><a href="/docs/features/software-catalog/software-catalog-overview">Software Catalog</a><a href="/docs/plugins/create-a-plugin">Create a Plugin</a><a href="/docs/dls/design">Designing for Backstage</a></div><div><h5>Community</h5><a href="https://discord.gg/MUpMjP2">Support chatroom</a><a href="https://github.com/backstage/backstage/blob/master/CONTRIBUTING.md">Contributing</a><a href="https://backstage.spotify.com">Adopting</a><a href="https://github.com/backstage/community">Community Sessions</a><a href="https://info.backstage.spotify.com/newsletter_subscribe">Subscribe to our newsletter</a><a href="https://www.cncf.io/projects/">CNCF Incubation</a></div><div><h5>More</h5><a href="https://spotify.github.io/">Open Source @ Spotify</a><a href="https://engineering.atspotify.com/">Spotify Engineering Blog</a><a href="https://developer.spotify.com/">Spotify for Developers</a><a href="https://github.com/backstage/backstage">GitHub</a><a class="github-button" href="https://github.com/backstage/backstage" data-icon="octicon-star" data-count-href="/backstage/backstage/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a><div class="social"><a href="https://twitter.com/SpotifyEng" class="twitter-follow-button">Follow @SpotifyEng</a></div></div></section><p style="text-align:center"><a href="https://spotify.github.io">Made with ❤️ at Spotify</a></p><p class="copyright">Copyright © 2023 Backstage Project Authors. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our Trademark Usage page: https://www.linuxfoundation.org/trademark-usage</p></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'JCMFNHCHI8',
                apiKey: '10b9e6c92a4513c1cf390f50e53aad1f',
                indexName: 'backstage_io',
                inputSelector: '#search_input_react'
              });
            </script></body></html>